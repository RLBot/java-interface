// automatically generated by the FlatBuffers compiler, do not modify

package rlbot.flat;

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Definition of a match.
 * Can be sent to RLBot to request the start of a match.
 */
@SuppressWarnings("unused")
public final class MatchConfiguration extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_25_2_10(); }
  public static MatchConfiguration getRootAsMatchConfiguration(ByteBuffer _bb) { return getRootAsMatchConfiguration(_bb, new MatchConfiguration()); }
  public static MatchConfiguration getRootAsMatchConfiguration(ByteBuffer _bb, MatchConfiguration obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public MatchConfiguration __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * How to launch Rocket League.
   * If left unset, RLBot will not launch the game.
   * To use Legendary, use Custom and set launcher_arg="legendary".
   */
  public int launcher() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  /**
   * Additional configuration for the launching method.
   * See launcher.
   */
  public String launcherArg() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer launcherArgAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer launcherArgInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * If true, RLBot will start the bots and scripts that has a non-empty run command in their player/script configuration.
   */
  public boolean autoStartAgents() { int o = __offset(8); return o != 0 ? 0!=bb.get(o + bb_pos) : true; }
  /**
   * If true, RLBot will start the match only once all bots and script have connected and are ready.
   * If false, the match will start as soon as the map loads.
   */
  public boolean waitForAgents() { int o = __offset(10); return o != 0 ? 0!=bb.get(o + bb_pos) : true; }
  /**
   * The name of a upk file, like UtopiaStadium_P, which should be loaded.
   * On Steam version of Rocket League this can be used to load custom map files,
   * but on Epic version it only works on the Psyonix maps.
   * Available maps can be found here: https://github.com/VirxEC/python-interface/blob/master/rlbot/utils/maps.py
   */
  public String gameMapUpk() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer gameMapUpkAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer gameMapUpkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The players in the match.
   */
  public rlbot.flat.PlayerConfiguration playerConfigurations(int j) { return playerConfigurations(new rlbot.flat.PlayerConfiguration(), j); }
  public rlbot.flat.PlayerConfiguration playerConfigurations(rlbot.flat.PlayerConfiguration obj, int j) { int o = __offset(14); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int playerConfigurationsLength() { int o = __offset(14); return o != 0 ? __vector_len(o) : 0; }
  public rlbot.flat.PlayerConfiguration.Vector playerConfigurationsVector() { return playerConfigurationsVector(new rlbot.flat.PlayerConfiguration.Vector()); }
  public rlbot.flat.PlayerConfiguration.Vector playerConfigurationsVector(rlbot.flat.PlayerConfiguration.Vector obj) { int o = __offset(14); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The custom scripts used in the match.
   */
  public rlbot.flat.ScriptConfiguration scriptConfigurations(int j) { return scriptConfigurations(new rlbot.flat.ScriptConfiguration(), j); }
  public rlbot.flat.ScriptConfiguration scriptConfigurations(rlbot.flat.ScriptConfiguration obj, int j) { int o = __offset(16); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int scriptConfigurationsLength() { int o = __offset(16); return o != 0 ? __vector_len(o) : 0; }
  public rlbot.flat.ScriptConfiguration.Vector scriptConfigurationsVector() { return scriptConfigurationsVector(new rlbot.flat.ScriptConfiguration.Vector()); }
  public rlbot.flat.ScriptConfiguration.Vector scriptConfigurationsVector(rlbot.flat.ScriptConfiguration.Vector obj) { int o = __offset(16); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The game mode.
   * This affects a few of the game rules although many game modes can also be recreated solely from mutators.
   * See what mutators and game mode combinations make up the official modes at https://github.com/VirxEC/python-interface/tree/master/tests/gamemodes
   */
  public int gameMode() { int o = __offset(18); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  /**
   * Whether to skip goal replays.
   */
  public boolean skipReplays() { int o = __offset(20); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Whether to start without a kickoff countdown.
   */
  public boolean instantStart() { int o = __offset(22); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Mutator settings.
   */
  public rlbot.flat.MutatorSettings mutators() { return mutators(new rlbot.flat.MutatorSettings()); }
  public rlbot.flat.MutatorSettings mutators(rlbot.flat.MutatorSettings obj) { int o = __offset(24); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * How to handle any ongoing match.
   */
  public int existingMatchBehavior() { int o = __offset(26); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  /**
   * Whether debug rendering is displayed.
   */
  public int enableRendering() { int o = __offset(28); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  /**
   * Whether clients are allowed to manipulate the game state, e.g. teleporting cars and ball.
   */
  public boolean enableStateSetting() { int o = __offset(30); return o != 0 ? 0!=bb.get(o + bb_pos) : true; }
  /**
   * Whether the match replay should be saved.
   */
  public boolean autoSaveReplay() { int o = __offset(32); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * If set to true, a free play match is launched instead of an exhibition match.
   * This allows the players to use training keybinds, Bakkesmod plugins, and other features that are only allowed in free play.
   */
  public boolean freeplay() { int o = __offset(34); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }

  public static int createMatchConfiguration(FlatBufferBuilder builder,
      int launcher,
      int launcherArgOffset,
      boolean autoStartAgents,
      boolean waitForAgents,
      int gameMapUpkOffset,
      int playerConfigurationsOffset,
      int scriptConfigurationsOffset,
      int gameMode,
      boolean skipReplays,
      boolean instantStart,
      int mutatorsOffset,
      int existingMatchBehavior,
      int enableRendering,
      boolean enableStateSetting,
      boolean autoSaveReplay,
      boolean freeplay) {
    builder.startTable(16);
    MatchConfiguration.addMutators(builder, mutatorsOffset);
    MatchConfiguration.addScriptConfigurations(builder, scriptConfigurationsOffset);
    MatchConfiguration.addPlayerConfigurations(builder, playerConfigurationsOffset);
    MatchConfiguration.addGameMapUpk(builder, gameMapUpkOffset);
    MatchConfiguration.addLauncherArg(builder, launcherArgOffset);
    MatchConfiguration.addFreeplay(builder, freeplay);
    MatchConfiguration.addAutoSaveReplay(builder, autoSaveReplay);
    MatchConfiguration.addEnableStateSetting(builder, enableStateSetting);
    MatchConfiguration.addEnableRendering(builder, enableRendering);
    MatchConfiguration.addExistingMatchBehavior(builder, existingMatchBehavior);
    MatchConfiguration.addInstantStart(builder, instantStart);
    MatchConfiguration.addSkipReplays(builder, skipReplays);
    MatchConfiguration.addGameMode(builder, gameMode);
    MatchConfiguration.addWaitForAgents(builder, waitForAgents);
    MatchConfiguration.addAutoStartAgents(builder, autoStartAgents);
    MatchConfiguration.addLauncher(builder, launcher);
    return MatchConfiguration.endMatchConfiguration(builder);
  }

  public static void startMatchConfiguration(FlatBufferBuilder builder) { builder.startTable(16); }
  public static void addLauncher(FlatBufferBuilder builder, int launcher) { builder.addByte(0, (byte) launcher, (byte) 0); }
  public static void addLauncherArg(FlatBufferBuilder builder, int launcherArgOffset) { builder.addOffset(1, launcherArgOffset, 0); }
  public static void addAutoStartAgents(FlatBufferBuilder builder, boolean autoStartAgents) { builder.addBoolean(2, autoStartAgents, true); }
  public static void addWaitForAgents(FlatBufferBuilder builder, boolean waitForAgents) { builder.addBoolean(3, waitForAgents, true); }
  public static void addGameMapUpk(FlatBufferBuilder builder, int gameMapUpkOffset) { builder.addOffset(4, gameMapUpkOffset, 0); }
  public static void addPlayerConfigurations(FlatBufferBuilder builder, int playerConfigurationsOffset) { builder.addOffset(5, playerConfigurationsOffset, 0); }
  public static int createPlayerConfigurationsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startPlayerConfigurationsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addScriptConfigurations(FlatBufferBuilder builder, int scriptConfigurationsOffset) { builder.addOffset(6, scriptConfigurationsOffset, 0); }
  public static int createScriptConfigurationsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startScriptConfigurationsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addGameMode(FlatBufferBuilder builder, int gameMode) { builder.addByte(7, (byte) gameMode, (byte) 0); }
  public static void addSkipReplays(FlatBufferBuilder builder, boolean skipReplays) { builder.addBoolean(8, skipReplays, false); }
  public static void addInstantStart(FlatBufferBuilder builder, boolean instantStart) { builder.addBoolean(9, instantStart, false); }
  public static void addMutators(FlatBufferBuilder builder, int mutatorsOffset) { builder.addOffset(10, mutatorsOffset, 0); }
  public static void addExistingMatchBehavior(FlatBufferBuilder builder, int existingMatchBehavior) { builder.addByte(11, (byte) existingMatchBehavior, (byte) 0); }
  public static void addEnableRendering(FlatBufferBuilder builder, int enableRendering) { builder.addByte(12, (byte) enableRendering, (byte) 0); }
  public static void addEnableStateSetting(FlatBufferBuilder builder, boolean enableStateSetting) { builder.addBoolean(13, enableStateSetting, true); }
  public static void addAutoSaveReplay(FlatBufferBuilder builder, boolean autoSaveReplay) { builder.addBoolean(14, autoSaveReplay, false); }
  public static void addFreeplay(FlatBufferBuilder builder, boolean freeplay) { builder.addBoolean(15, freeplay, false); }
  public static int endMatchConfiguration(FlatBufferBuilder builder) {
    int o = builder.endTable();
    builder.required(o, 6);  // launcher_arg
    builder.required(o, 12);  // game_map_upk
    builder.required(o, 14);  // player_configurations
    builder.required(o, 16);  // script_configurations
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public MatchConfiguration get(int j) { return get(new MatchConfiguration(), j); }
    public MatchConfiguration get(MatchConfiguration obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
  public MatchConfigurationT unpack() {
    MatchConfigurationT _o = new MatchConfigurationT();
    unpackTo(_o);
    return _o;
  }
  public void unpackTo(MatchConfigurationT _o) {
    int _oLauncher = launcher();
    _o.setLauncher(_oLauncher);
    String _oLauncherArg = launcherArg();
    _o.setLauncherArg(_oLauncherArg);
    boolean _oAutoStartAgents = autoStartAgents();
    _o.setAutoStartAgents(_oAutoStartAgents);
    boolean _oWaitForAgents = waitForAgents();
    _o.setWaitForAgents(_oWaitForAgents);
    String _oGameMapUpk = gameMapUpk();
    _o.setGameMapUpk(_oGameMapUpk);
    rlbot.flat.PlayerConfigurationT[] _oPlayerConfigurations = new rlbot.flat.PlayerConfigurationT[playerConfigurationsLength()];
    for (int _j = 0; _j < playerConfigurationsLength(); ++_j) {_oPlayerConfigurations[_j] = (playerConfigurations(_j) != null ? playerConfigurations(_j).unpack() : null);}
    _o.setPlayerConfigurations(_oPlayerConfigurations);
    rlbot.flat.ScriptConfigurationT[] _oScriptConfigurations = new rlbot.flat.ScriptConfigurationT[scriptConfigurationsLength()];
    for (int _j = 0; _j < scriptConfigurationsLength(); ++_j) {_oScriptConfigurations[_j] = (scriptConfigurations(_j) != null ? scriptConfigurations(_j).unpack() : null);}
    _o.setScriptConfigurations(_oScriptConfigurations);
    int _oGameMode = gameMode();
    _o.setGameMode(_oGameMode);
    boolean _oSkipReplays = skipReplays();
    _o.setSkipReplays(_oSkipReplays);
    boolean _oInstantStart = instantStart();
    _o.setInstantStart(_oInstantStart);
    if (mutators() != null) _o.setMutators(mutators().unpack());
    else _o.setMutators(null);
    int _oExistingMatchBehavior = existingMatchBehavior();
    _o.setExistingMatchBehavior(_oExistingMatchBehavior);
    int _oEnableRendering = enableRendering();
    _o.setEnableRendering(_oEnableRendering);
    boolean _oEnableStateSetting = enableStateSetting();
    _o.setEnableStateSetting(_oEnableStateSetting);
    boolean _oAutoSaveReplay = autoSaveReplay();
    _o.setAutoSaveReplay(_oAutoSaveReplay);
    boolean _oFreeplay = freeplay();
    _o.setFreeplay(_oFreeplay);
  }
  public static int pack(FlatBufferBuilder builder, MatchConfigurationT _o) {
    if (_o == null) return 0;
    int _launcherArg = _o.getLauncherArg() == null ? 0 : builder.createString(_o.getLauncherArg());
    int _gameMapUpk = _o.getGameMapUpk() == null ? 0 : builder.createString(_o.getGameMapUpk());
    int _playerConfigurations = 0;
    if (_o.getPlayerConfigurations() != null) {
      int[] __playerConfigurations = new int[_o.getPlayerConfigurations().length];
      int _j = 0;
      for (rlbot.flat.PlayerConfigurationT _e : _o.getPlayerConfigurations()) { __playerConfigurations[_j] = rlbot.flat.PlayerConfiguration.pack(builder, _e); _j++;}
      _playerConfigurations = createPlayerConfigurationsVector(builder, __playerConfigurations);
    }
    int _scriptConfigurations = 0;
    if (_o.getScriptConfigurations() != null) {
      int[] __scriptConfigurations = new int[_o.getScriptConfigurations().length];
      int _j = 0;
      for (rlbot.flat.ScriptConfigurationT _e : _o.getScriptConfigurations()) { __scriptConfigurations[_j] = rlbot.flat.ScriptConfiguration.pack(builder, _e); _j++;}
      _scriptConfigurations = createScriptConfigurationsVector(builder, __scriptConfigurations);
    }
    int _mutators = _o.getMutators() == null ? 0 : rlbot.flat.MutatorSettings.pack(builder, _o.getMutators());
    return createMatchConfiguration(
      builder,
      _o.getLauncher(),
      _launcherArg,
      _o.getAutoStartAgents(),
      _o.getWaitForAgents(),
      _gameMapUpk,
      _playerConfigurations,
      _scriptConfigurations,
      _o.getGameMode(),
      _o.getSkipReplays(),
      _o.getInstantStart(),
      _mutators,
      _o.getExistingMatchBehavior(),
      _o.getEnableRendering(),
      _o.getEnableStateSetting(),
      _o.getAutoSaveReplay(),
      _o.getFreeplay());
  }
}

