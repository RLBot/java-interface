// automatically generated by the FlatBuffers compiler, do not modify

package rlbot.flat;

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * A RenderAnchor is a point in space consisting of a world component and optionally a relative component.
 * The relative component is given by a car or ball and includes a local offset that takes the orientation of the object into account.
 * The RenderAnchor stays attached to the object and does not have to be updated each tick.
 * Rendering that uses a RenderAnchor attached to an object disappears if the object is destroyed, i.e. the car demolished or the ball is scored.
 */
@SuppressWarnings("unused")
public final class RenderAnchor extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_25_2_10(); }
  public static RenderAnchor getRootAsRenderAnchor(ByteBuffer _bb) { return getRootAsRenderAnchor(_bb, new RenderAnchor()); }
  public static RenderAnchor getRootAsRenderAnchor(ByteBuffer _bb, RenderAnchor obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public RenderAnchor __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * An offset in global coordinates.
   * If the relative component is null, then this simply a point in 3D space.
   */
  public rlbot.flat.Vector3 world() { return world(new rlbot.flat.Vector3()); }
  public rlbot.flat.Vector3 world(rlbot.flat.Vector3 obj) { int o = __offset(4); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }
  public byte relativeType() { int o = __offset(6); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * An optional offset given by the position of an object and includes a local offset that takes the object's orientation into account.
   */
  public Table relative(Table obj) { int o = __offset(8); return o != 0 ? __union(obj, o + bb_pos) : null; }

  public static void startRenderAnchor(FlatBufferBuilder builder) { builder.startTable(3); }
  public static void addWorld(FlatBufferBuilder builder, int worldOffset) { builder.addStruct(0, worldOffset, 0); }
  public static void addRelativeType(FlatBufferBuilder builder, byte relativeType) { builder.addByte(1, relativeType, 0); }
  public static void addRelative(FlatBufferBuilder builder, int relativeOffset) { builder.addOffset(2, relativeOffset, 0); }
  public static int endRenderAnchor(FlatBufferBuilder builder) {
    int o = builder.endTable();
    builder.required(o, 4);  // world
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public RenderAnchor get(int j) { return get(new RenderAnchor(), j); }
    public RenderAnchor get(RenderAnchor obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
  public RenderAnchorT unpack() {
    RenderAnchorT _o = new RenderAnchorT();
    unpackTo(_o);
    return _o;
  }
  public void unpackTo(RenderAnchorT _o) {
    if (world() != null) world().unpackTo(_o.getWorld());
    else _o.setWorld(null);
    rlbot.flat.RelativeAnchorUnion _oRelative = new rlbot.flat.RelativeAnchorUnion();
    byte _oRelativeType = relativeType();
    _oRelative.setType(_oRelativeType);
    Table _oRelativeValue;
    switch (_oRelativeType) {
      case rlbot.flat.RelativeAnchor.BallAnchor:
        _oRelativeValue = relative(new rlbot.flat.BallAnchor());
        _oRelative.setValue(_oRelativeValue != null ? ((rlbot.flat.BallAnchor) _oRelativeValue).unpack() : null);
        break;
      case rlbot.flat.RelativeAnchor.CarAnchor:
        _oRelativeValue = relative(new rlbot.flat.CarAnchor());
        _oRelative.setValue(_oRelativeValue != null ? ((rlbot.flat.CarAnchor) _oRelativeValue).unpack() : null);
        break;
      default: break;
    }
    _o.setRelative(_oRelative);
  }
  public static int pack(FlatBufferBuilder builder, RenderAnchorT _o) {
    if (_o == null) return 0;
    byte _relativeType = _o.getRelative() == null ? rlbot.flat.RelativeAnchor.NONE : _o.getRelative().getType();
    int _relative = _o.getRelative() == null ? 0 : rlbot.flat.RelativeAnchorUnion.pack(builder, _o.getRelative());
    startRenderAnchor(builder);
    addWorld(builder, rlbot.flat.Vector3.pack(builder, _o.getWorld()));
    addRelativeType(builder, _relativeType);
    addRelative(builder, _relative);
    return endRenderAnchor(builder);
  }
}

