// automatically generated by the FlatBuffers compiler, do not modify

package rlbot.flat;

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Information about the current match such as time and gravity.
 */
@SuppressWarnings("unused")
public final class MatchInfo extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_25_2_10(); }
  public static MatchInfo getRootAsMatchInfo(ByteBuffer _bb) { return getRootAsMatchInfo(_bb, new MatchInfo()); }
  public static MatchInfo getRootAsMatchInfo(ByteBuffer _bb, MatchInfo obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public MatchInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * How many seconds have elapsed since the first game packet of the match.
   * This value ticks up even during kickoffs, replays, pause, etc.
   */
  public float secondsElapsed() { int o = __offset(4); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Seconds remaining of the match.
   * This value ticks up instead of down during overtime or when the game duration mutator is set to Unlimited.
   * I.e. it matches the in-game timer at the top.
   */
  public float gameTimeRemaining() { int o = __offset(6); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * True if the game is in overtime.
   */
  public boolean isOvertime() { int o = __offset(8); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if the game duration is set to Unlimited.
   */
  public boolean isUnlimitedTime() { int o = __offset(10); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The current phase of the match, i.e. kickoff, replay, active, etc.
   */
  public int matchPhase() { int o = __offset(12); return o != 0 ? bb.get(o + bb_pos) & 0xFF : 0; }
  /**
   * The current strength of gravity. Default is -650.
   */
  public float worldGravityZ() { int o = __offset(14); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Game speed multiplier. Regular game speed is 1.0.
   */
  public float gameSpeed() { int o = __offset(16); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Index of the player who was most recently a spectated by the host.
   */
  public long lastSpectated() { int o = __offset(18); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }
  /**
   * Tracks the number of physics frames the game has computed.
   * May increase by more than one across consecutive packets.
   * Data type will roll over after 414 days at 120Hz.
   */
  public long frameNum() { int o = __offset(20); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }

  public static int createMatchInfo(FlatBufferBuilder builder,
      float secondsElapsed,
      float gameTimeRemaining,
      boolean isOvertime,
      boolean isUnlimitedTime,
      int matchPhase,
      float worldGravityZ,
      float gameSpeed,
      long lastSpectated,
      long frameNum) {
    builder.startTable(9);
    MatchInfo.addFrameNum(builder, frameNum);
    MatchInfo.addLastSpectated(builder, lastSpectated);
    MatchInfo.addGameSpeed(builder, gameSpeed);
    MatchInfo.addWorldGravityZ(builder, worldGravityZ);
    MatchInfo.addGameTimeRemaining(builder, gameTimeRemaining);
    MatchInfo.addSecondsElapsed(builder, secondsElapsed);
    MatchInfo.addMatchPhase(builder, matchPhase);
    MatchInfo.addIsUnlimitedTime(builder, isUnlimitedTime);
    MatchInfo.addIsOvertime(builder, isOvertime);
    return MatchInfo.endMatchInfo(builder);
  }

  public static void startMatchInfo(FlatBufferBuilder builder) { builder.startTable(9); }
  public static void addSecondsElapsed(FlatBufferBuilder builder, float secondsElapsed) { builder.addFloat(0, secondsElapsed, 0.0f); }
  public static void addGameTimeRemaining(FlatBufferBuilder builder, float gameTimeRemaining) { builder.addFloat(1, gameTimeRemaining, 0.0f); }
  public static void addIsOvertime(FlatBufferBuilder builder, boolean isOvertime) { builder.addBoolean(2, isOvertime, false); }
  public static void addIsUnlimitedTime(FlatBufferBuilder builder, boolean isUnlimitedTime) { builder.addBoolean(3, isUnlimitedTime, false); }
  public static void addMatchPhase(FlatBufferBuilder builder, int matchPhase) { builder.addByte(4, (byte) matchPhase, (byte) 0); }
  public static void addWorldGravityZ(FlatBufferBuilder builder, float worldGravityZ) { builder.addFloat(5, worldGravityZ, 0.0f); }
  public static void addGameSpeed(FlatBufferBuilder builder, float gameSpeed) { builder.addFloat(6, gameSpeed, 0.0f); }
  public static void addLastSpectated(FlatBufferBuilder builder, long lastSpectated) { builder.addInt(7, (int) lastSpectated, (int) 0L); }
  public static void addFrameNum(FlatBufferBuilder builder, long frameNum) { builder.addInt(8, (int) frameNum, (int) 0L); }
  public static int endMatchInfo(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public MatchInfo get(int j) { return get(new MatchInfo(), j); }
    public MatchInfo get(MatchInfo obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
  public MatchInfoT unpack() {
    MatchInfoT _o = new MatchInfoT();
    unpackTo(_o);
    return _o;
  }
  public void unpackTo(MatchInfoT _o) {
    float _oSecondsElapsed = secondsElapsed();
    _o.setSecondsElapsed(_oSecondsElapsed);
    float _oGameTimeRemaining = gameTimeRemaining();
    _o.setGameTimeRemaining(_oGameTimeRemaining);
    boolean _oIsOvertime = isOvertime();
    _o.setIsOvertime(_oIsOvertime);
    boolean _oIsUnlimitedTime = isUnlimitedTime();
    _o.setIsUnlimitedTime(_oIsUnlimitedTime);
    int _oMatchPhase = matchPhase();
    _o.setMatchPhase(_oMatchPhase);
    float _oWorldGravityZ = worldGravityZ();
    _o.setWorldGravityZ(_oWorldGravityZ);
    float _oGameSpeed = gameSpeed();
    _o.setGameSpeed(_oGameSpeed);
    long _oLastSpectated = lastSpectated();
    _o.setLastSpectated(_oLastSpectated);
    long _oFrameNum = frameNum();
    _o.setFrameNum(_oFrameNum);
  }
  public static int pack(FlatBufferBuilder builder, MatchInfoT _o) {
    if (_o == null) return 0;
    return createMatchInfo(
      builder,
      _o.getSecondsElapsed(),
      _o.getGameTimeRemaining(),
      _o.getIsOvertime(),
      _o.getIsUnlimitedTime(),
      _o.getMatchPhase(),
      _o.getWorldGravityZ(),
      _o.getGameSpeed(),
      _o.getLastSpectated(),
      _o.getFrameNum());
  }
}

